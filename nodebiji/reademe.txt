http://www.jianshu.com/p/91b41db5736c
在node中一个js文件就是一个module
使用模块的好处：
就是打打提高了代码的可维护性格，其次代码不用从零开始写了，当一个模块编写完毕之后，就可以被其他地方引用，我们在编写程序的时候,也常常引用其他模块

在node中设置一个模块的时候
1.js
var name=1;
function say(){
	console.log(name)
}
module.export=say

2.js
var say=require('./1.js');

如果只是写模块名字，则node会依次在内置模块，全局模块，当期那模块下查找1.js 很有可能错误的


这种模块机制是commonjs规范。每个js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突；
一个模块想要对外暴露变量module.exports=name
一个模块想要引用其他模块暴露的变量 var name=require("./1")

一.深入了解模块原理
1.原理：
在编写js的时候，我们会申请全局变量，但是在浏览器中大量使用全局变量不好，可能会造成冲突。
因为上文中的这个，所以我们需要实现模块这种功能，其实在node中实现模块这种功能，并不需要语法层面的支持，nodejs也并不会增加任何js语法，实现模块功能的奥妙在于js本身是一种函数式的编程语言，它支持闭包。如果我们把一段js代码用一个函数包装起来，这段代码所有的全局变量就变成了函数内部的局部变量
来一个实例：
hello.js
var s='hello';
var name='world';
console.log(s+":"+name);
通过nodejs之后，就会把代码包装一下，
(function(){
	var s='hello';
	var name="world";
	console.log(s+":"+name)
})();
这样的话所有的全局变量就变成了匿名函数内部的局部变量。就算nondejs继续加载其他模块，这些模块中定义的全局变量也是互不干扰的。

2.模块的输出是怎么实现的：
node自己会先准备一个module
var module={
	id:'hello',
	exports:{}
};
var load=function(module){
	//hello代码
	function greet(name){
		console.log('hello,',+name+'!');
	}
	module.exports=greet;
	//module代码结束
	return module.exports;
};
var exported=load(module);
save(module,exported);
这个例子可以看到变量module是node在加载js文件之前准备的一个变量，并且将其传入加载函数，我们在hello.js中可以直接使用变量module原因就在于它实际上是函数的一个参数：module.exports=greet
通过把参数module传递给load函数，hellojs就顺利的把一个变量传递给node执行环境，node会把module变量保存在某个地方
由于node保存了所有导入的module,当我们用require获取module的时候，node找到对应的module,把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出


--------------------------------
3.比较module.exports 和 exports
module.exports
module.exports={hello:hello,hreet:greet}

exports
exports.hello=hello;
exports.greet=greet

????原理自己在看
结论：
如果要输出的是有一个键值对象{}，可以利用exports这个已经存在的空对象{}，并继续在上面添加新的键值
如果要输出一个函数或者数组，必须使用module.exports对象赋值
最后我们直接用module.exports赋值就可以了，可以应对全部的情况
---------------------------------
4.基本模块-global
在浏览器中我们是一个window对象
在服务端中我们是一个global对象
进入node交互环境，输入global.console
----------------------------------
5.基本模块-process
代表nodejs的进程，通过process对象可以拿到需要有用的信息

js程序是由事件驱动执行的单线程模型，nodejs也是。nodejs不断执行响应事件的js函数，直到没有任何响应事件的函数可以执行，nodejs就退出了
如果我们想要在下一个事件响应中执行代码，可以调用process.nextTick()
process.nextTick(function(){
	console.log('nextTick callback')
});
console.log('nextTick was set')
得到的结果是：
nextTick was set!
nextTick callback
这个说明process.nextTick的函数不是立刻执行的，而是等到下一次事件循环。
node本身是有process对象来处理的，如果我们响应exit事件，就可以在程序即将退出的时候执行某个回调函数。
process.on('exit',function(code){
	console.log('about')
})

--------------------------------
6.判断js执行的环境
有些时候，我们需要判断自己在什么环境下执行的，常用的方式就是根据浏览器和node环境提供的全局变量的名字进行判断
if(typeof(window)==='undefined'){
//因为node的全局变量是global
	console.log('node.js')
}else{
	console.log('browser')
}

------------------------------
7.内置模块-fs
nodejs的内置fs模块是文件系统模块，负责读写文件的。
和其他的js模块不同的是，fs模块同时提供了异步和同步的方法
因为js是单线程的，执行io操作的时候，js代码无需等待，而是传入回调函数后，继续执行后面的js代码

异步读取文件
var fs=require('fs');
fs.readFile('sample.txt','utf-8',function(err,data){
	if(err){//出现错误的话
		console.log(err)
	}else{//正确的
		console.log(data);
	}
})
异步读取图片 和上面是一样的
var fs=require("fs");
fs.readFile('logo.png',function(err,data){
	if(err){
		console.log(err)
	}else{
		console.log(data);
		console.log(data.length)
	}
})
当读取二进制文件的时候，不传入文件编码的时候，回调函数的data参数将返回一个buffer对象，在nodejs中，buffer对象就是一个包含零个或任意个字节的数组
其中buffer转化为string
var text=data.toString('utf-8')
string转化为buffer
var buf=new Buffer(text,'utf-8')

---------------------------------
8.同步读取文件
除了标准的异步读取文件之外，fs也提供了相应的同步读取函数。同步读取函数和异步函数相比，多了一个sync后缀，并且不接收回调函数，函数直接返回结构
var fs=require('fs');
var data=fs.readFileSync('1.txt','utf-8');
console.log(data)
捕获错误的时候
try{
	var data=fs.readFileSync('1.txt','utf-8');
	console.log('data')
}catch(err){
	//错误
}

-------------------------------
9.写文件
将数据写入文件通过fs.writeFile()实现的
var fs=require('fs');
var data='hello,world123';
fs.writeFile('1.txt',data,function(err){
	if(err){
		console.log(err)
	}else{
		console.log('成功');
	}
})
使用writeFile函数的参数依次是文件名字 数据 回调函数
如果传入的是utf-8就写入文本文件；如果传入的是buffer，就写图二进制文件

同样的和读取文件的一样有同步的writeFileSync()
var fs=require("fs");
var data='hello';
fs.writeFileSync('1.txt',data);

-----------------------------------
10.stat
如果要获取文件大小，创建时间等信息，可以使用fs.stat()
var fs=require("fs");
fs.stat('1.txt',function(err,stat){
	if(err){
		console.log(err)
	}else{
		console.log(stat)
	}
})
stat.isFile是否是文件 
stat.isDirectory是否是目录
stat.size大小
stat.birthtime创建时间
stat.mtime修改的事件
上面的同样是异步的 对应的有同步的statSync

-------------------------------
11.异步还是同步
因为node环境执行的js代码都是服务器端的代码。。所以，绝大部分需要在服务器运行期间反复执行业务逻辑的代码，必须使用异步代码。否则，同步代码在执行时期，服务器将停止响应，因为js只有一个执行线程

-------------------------------------
12.stream
stream是nodejs提供的一个仅在服务区端可用的模块，目的就是支持流这种数据结构。
什么是流？流就是一种抽象的数据结构，想象水流，当在水管中流动的时候，就可以从某个地方源源不断的到达另一个地方。
我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成是字符流。这个流是从键盘输入到应用程序，实例上它还对应着一个名字：标准输入流

如果应用程序把字符一个一个输出到显示器上这也可以看成是一个流，这个流也有名字：标准输出流。
流的特点是数据是有序的，而且必须依次读取，或者依次写入，不想array那样随记定位

在nodejs中流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到了末尾了，没有数据可以读取了，error事件表示出错了
var fs=require('fs');
var fs=fs.createReadStream('1.txt','utf-8');
fs.on('data',function(chunk){
	console.log('data'+chunk)
});
fs.on('end',function(){
	console.log('end')
});
fs.on('error',function(err){
	console.log('error'+err)
})
要注意的是data事件可能会出现很多次，每次传递的chunk是流的一部分数据
要以流的形式写入文件，只需要不断的调用write文件，最后以end结束就可以了
var fs=require('fs');
var ws1=fs.createWriteStream('1.txt','utf-8');
ws1.write('使用stream');
ws1.write('end');
ws1.end();
所有可以读取数据的流都继承自stream.Readable
所有可以写入的流都继承自stream.Writeable

------------------------------------------
13.pipe
就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个readable流和一个writeable流串起来后，所有的数据自动从readable流进入writeable流，这种操作叫pipe

在node中,readable流有一个pipe方法，就是用来干这件事的
让我们用pipe()把一个文件流和另一个文件流串起来，这样源文件所有数据就自动写入到目标文件中了，所以这实际上是一个复制文件的程序
var fs=require('fs');
var rs=fs.createReadStream('1.txt');
var ws=fs.createWriteStream('2.txt');
rs.pipe(ws);
默认情况下，当readable流的数据读取完毕，end事件触发后，将自动关闭writeable流，如果我们不希望自动关闭writeable流，需要传入参数
readable.pipe(writeable,{end:false})

-------------------------------------------
14.http

------------------------------------------
15.http协议

------------------------------------------
16.http服务器
要开发http服务器程序，从头处理tcp程序，解析http是不现实的，这些工作实际上已经由node自带的http模块完成了。应用程序并不直接和http协议打交道，而是操作http模块提供的request和response对象

request对象封装了http请求，我们调用request对象的属性和方法就可以拿到所有的http请求的信息；

response对象封装了http响应，我们操作response对象的方法，就可以把http响应返回给浏览器

用nodejs实现一个http服务器程序非常简单，我们来实现一个最简单的web程序hello.js,他对于所有请求，都返回hello world
var http=require('http');
//创建http 并传入回调函数
var server=http.createServer(function(request,response){
	//回调函数接收到request response
	//获取http请求的method 和url
	console.log(request.method+":"+request.url);
	//将http响应写入response 同时设置Content-type:text/html
	response.writeHead(200,{'Content-Type':'text/html'});
	//将http响应的html内容写入response
	response.end('<h1>hello</h1>')
});
server.listen(8080);
console.log('Server is running at http://127.0.0.1:8080')
然后再命令行中输入
node 1.js Server is running at http://127.0.0.1:8080
然后打开浏览器http://localhost:8080 就可以看到浏览器的内容了

-----------------------------------------------------
17.文件服务器
可以设定一个目录，然后让web程序变成一个文件服务器。要实现这个，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。

解析url，我们可以用到node的url模块，它使用起来是非常方便的。通过parse()将一个字符串解析成一个url对象





















